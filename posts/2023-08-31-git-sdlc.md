----------
title: Git-Based Software Development Life-Cycle
----------


# Introduction

Recently a co-worker lamented that his Jira-history will be gone once he
finishes the project. With it goes all (functional-safety relevant)
documentation that has accrued in there. Exporting each issue to a PDF with all
attachments will satisfy Q, but the useability is horrendeous. It will also
never make it back if the customer needs extensions in the future.


At the same time I stumbled upon
[`git-appraise`](https://github.com/google/git-appraise). This raised the
question, whether we can replace the web based tools with tools that store
their information, history and artifacts, in the repository. For our use-cases
we would have to replace the following tools:

* *Jira*: Issue-tracking and general project management
* *Confluence*: Wiki and documentation tools
* *Bamboo*: CI/CD server
* *Artifactory*: Storing (Docker) images and other artifacts from/for CI/CD
* *Gerrit*: Code reviews
* *Bitbucket*: we're working in a git repositry, it can be stored anywhere. It's not relevant here.

I want to *emphasize* that the replacement isn't the relevant question. This is
the CLI nerd in me speaking. It'll be a hard sell to convince our customers to
use bash instead of a familiar web UI. The *main point* is keeping all relevant
data in the same place as the code.


# Jira

## Use Cases

I figure Jira is at its core an issue tracker with a set of boards (kanban,
backlog, ...). The issue can have various status flows attached to them.

Here's an incomplete list of responsabilities/use-cases propped upon Jira by
ingenious PMO that need to be addressed.

* (Kanban) Board / Backlog
* Release Planning
* Earned Value / Spent Effort tracking and planning
* Release Notes
* Requirements/Bugs discussions
	* Attachments. It seems to be a relevant use-case to store attachments with issues.

⚠ Question for the readers: what other use-cases have been implemented with it?


## Issue/Bug Tracking

For the basic use-case of tracking *Issues* and *Bugs* is covered by either of
the following tools. Their respective advantages and downsides are addressed.

### git issue

There's [git-issue](https://github.com/dspinellis/git-issue) with an introductory
video at [FOSDEM'20](https://archive.fosdem.org/2020/schedule/event/git_issue_management/).
It allows to do issue tracking in a git repository.

As a UI it supports syncing to *Gitlab* and *GitHub*. There their web interface
can be used instead.

### git bug

The tool [git-bug](https://github.com/MichaelMure/git-bug) seems to support the
same basic features. The biggest drawback seem to be the lack of attachments
to issues. On the plus side there are multiple UI front ends, e.g., terminal,
web, &c.

There's even a [board](https://github.com/MichaelMure/git-bug/pull/843) under
development.

## Release Planning

In Jira one can define the release for which the issue will be fixed. Then all
issues that are part of the release show up in the release page of that specific
release. With this mechanism one can check if all issues that are planned for a
release are done.

### Release Notes

Storing release information in the respective issues sounds compelling. It's
not a dedicated tool for the task. The release notes need to be stiched together
manually.

As an example, have a look at [scriv](https://github.com/nedbat/scriv).


## Earned Value / Effort Spent

This is supported by `git-issue`. However it's not supported by `git-bug`.

If the information needs to be duplicated in your time-tracking software, I
suggest you track the information there or your project design Excel file.
There's also *Projects* for the more serious project managers.


## Boards

Boards are used to organise issues, bugs, and workflows. Boards only make sense
if there's a proper UI. Hence the only the state needs to be synced.

Support for boards is currently under development in `git-bug`. Whether this
information can be synced is rather unclear. However upon completion of a
(sub-)project this information is rather moot.

## Requirements

Missing from the above list is a suitable tool to track requirements. I've
heard people do this in Jira. This brings us back to the above problem and
probably shouldn't be done anyways. Including requirements we should have a
complete UNIX philosophy inspired ALM "tool".

See the following free and open options:

* [sphinx-needs](https://sphinx-needs.readthedocs.io/en/latest/)
* [rmtoo](http://rmtoo.florath.net/)
* [doorstop](https://doorstop.readthedocs.io/en/latest/).
* there are others; give it a go in your favourite search engine.

# Confluence

It's about the only collaborative WYSIWYG wiki out there. The only alternative
out there is probably Sharepoint. VCS tracked markdown wikis are plentiful,
e.g., GitHub uses that for their Wikis.

Locally editing and live-preview is probably a solved problem, e.g., [Gollum]
(https://github.com/gollum/gollum). Merely editing markdown see, e.g.,
(https://typora.io/).

⚠ Linking to issues from the wiki has been used successfully. This can be
emulated by creating links to the git-bug ID. This is however not very
transferrable to any web UI.


# Bamboo

Alternatives to centrally hosted CI/CD tooling should be available at every
turn. Jenkins certainly provides everything, the hosting requires some effort
though to keep up-to-date.

We assume our builds and tests are going to be reproducible. Then we should be
able to run the tests, builds, &c. locally without a centralized
infrastructure.

[Act](https://github.com/nektos/act) allows us to run our CI/CD pipeline
locally. The syntax promises to be *GitHub Actions* compatible.

# Artifactory

It is questionable whether this tool can be replaced. We need some form of
repository for the OS abstraction. Be that docker, podman, or some other images.
These images can't be reasonably stored in a git repository.

If there are no Docker artifacts being generated, the artifacts can be pushed
to the repository using git-lfs. A method to avoid build-loops must be devised
if a CI is used.


# Gerrit

With [`git-appraise`](https://github.com/google/git-appraise) we can do code reviews
in the console. The results are also stored under revision control.

There's even a read-only [UI](https://github.com/google/git-appraise-web).


# Conclusion

It should be possible to do the full workflow on the console. However, if we use
the exisiting web UI, we can leverage the UX advantages and still keep
most of the information in our git repository.

## Missing Key Features

* Putting attachements on issues in Jira will not transfer at the moment.
* Confluence probably doesn't export gracefully either.
